<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Vue3开篇 | Promise</title><meta name="author" content="想名是真的难"><meta name="copyright" content="想名是真的难"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="系统学习Vue3">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue3开篇">
<meta property="og:url" content="http://example.com/post/4a17b156.html">
<meta property="og:site_name" content="Promise">
<meta property="og:description" content="系统学习Vue3">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://picx.zhimg.com/80/v2-781cbee858456bdb05399d0569b11416_720w.webp?source=1940ef5c">
<meta property="article:published_time" content="2023-03-21T08:21:05.662Z">
<meta property="article:modified_time" content="2023-04-21T09:18:44.676Z">
<meta property="article:author" content="想名是真的难">
<meta property="article:tag" content="Vue3">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://picx.zhimg.com/80/v2-781cbee858456bdb05399d0569b11416_720w.webp?source=1940ef5c"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/post/4a17b156.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Vue3开篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-21 17:18:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">1</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Promise"><span class="site-name">Promise</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Vue3开篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-21T08:21:05.662Z" title="发表于 2023-03-21 16:21:05">2023-03-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-21T09:18:44.676Z" title="更新于 2023-04-21 17:18:44">2023-04-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Vue3开篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h2 id="构建Vue3项目"><a href="#构建Vue3项目" class="headerlink" title="构建Vue3项目"></a><strong>构建Vue3项目</strong></h2><ul>
<li>使用<strong>vite</strong>初始化一个项目 npm(<strong>npm init vite@latest</strong>)  yarn(<strong>yarn create vite</strong>)</li>
<li>使用<strong>vue-cli</strong>脚手架(npm install @vue&#x2F;cli -g)来创建    <strong>vue create <project></strong></li>
</ul>
<h2 id="Vue2与Vue3的区别"><a href="#Vue2与Vue3的区别" class="headerlink" title="Vue2与Vue3的区别"></a><strong>Vue2与Vue3的区别</strong></h2><ul>
<li><p>Vue2中更新diff，每次都是<strong>全量对比</strong>。Vue3增加了<strong>patch flag</strong> 标记，只对比<strong>带有标记</strong>的,这样大大减少了非动态内容的对比消耗。</p>
</li>
<li><p>Vue3允许支持多个根节点，在外层增加了一个<strong>Fragment</strong>标签。</p>
</li>
<li><p>Vue3引入了<strong>Tree shaking</strong>特性，将全局 API 进行分块。如果你不使用其某些功能，它们将不会包含在你的基础包中。</p>
</li>
<li><p>Vue2使用的是<strong>Options API</strong>，Vue3使用的是<strong>Composition API</strong>，相比于Vue2，Vue3逻辑分明，可读性&#x2F;可维护性高。</p>
</li>
<li><p>Vue2基于<strong>Object.defineProperty()<strong>实现，Vue3基于</strong>Proxy</strong>实现，Proxy与Object.defineProperty()方式相比有以下优势：</p>
<ul>
<li>Vue2重写了数组的push、pop、shift、unshift、splice、sort、reverse常用方法对数组实现监听，Vue3通过Proxy可以直接监听到数组变化。</li>
<li>Object.defineProperty需要通过递归对对象每个属性进行数据监听，无法检测到对象属性的新增或者删除，只能追踪对象数据是否被修改。Proxy可以理解为目标对象之前做一层拦截，外部所有的访问都必须通过这层拦截。Proxy直接代理的是整个对象而非对象属性。</li>
</ul>
</li>
</ul>
<h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a><strong>虚拟DOM</strong></h2><p>​		虚拟DOM就是通过JS来生成一个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=AST&spm=1001.2101.3001.7020">AST</a>节点树。</p>
<h2 id="Vue中的Diff算法："><a href="#Vue中的Diff算法：" class="headerlink" title="Vue中的Diff算法："></a>Vue中的Diff算法：</h2><p>​		为了进一步降低找出差异的性能的性能消耗，就要使用diff算法。Diff算法是一种对比算法。对比两者是旧虚拟DOM和新虚拟DOM，对比出是哪个虚拟节点更改了，找出这个虚拟节点，并只更新这个虚拟节点所对应的真实节点，实现精准地更新真实DOM。</p>
<h2 id="Vue2Diff算法："><a href="#Vue2Diff算法：" class="headerlink" title="Vue2Diff算法："></a>Vue2Diff算法：</h2><p>​	vue2采用了<strong>双端diff算法</strong>。核心方法是<strong>updateChildren</strong>，通过<em>新前与旧前</em>、<em>新后与旧后</em>、<em>新后与旧前</em>、<em>新前与旧后</em>、<em>暴力比对</em>5种查找。</p>
<ul>
<li><p>​	新前：newChildren中所有未处理的第一个节点</p>
</li>
<li><p>​	新后：newChildren中所有未处理的最后一个节点</p>
</li>
<li><p>​	旧前：oldChildren中所有未处理的第一个节点</p>
</li>
<li><p>​	旧后：oldChildren中所有未处理的最后一个节点</p>
<p>在具体介绍前我们还需要了解<strong>isSameVnode</strong>这个用来对比两个节点是否相同的方法</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 判断两个vnode的标签和key是否相同 如果相同 就可以认为是同一节点就地复用</span><br><span class="line"><span class="keyword">function</span> isSameVnode(oldVnode, newVnode) &#123;</span><br><span class="line">  <span class="built_in">return</span> oldVnode.tag === newVnode.tag &amp;&amp; oldVnode.key === newVnode.key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="新前与旧前"><a href="#新前与旧前" class="headerlink" title="新前与旧前"></a>新前与旧前</h3><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87ed7a154aa3455faef62d97e7748612~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="image.png" style="zoom:80%;" />

<p>​	新前与旧前对比，如果相同，那么新、老的开始下标往后移动一格，上图中a的新老节点相同，位置移动b位置，此时新节点为f,两节点不同，进入新后与旧后比对</p>
<h3 id="新后与旧后"><a href="#新后与旧后" class="headerlink" title="新后与旧后"></a>新后与旧后</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d659069e84f546909abab72125a16c5c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p>
<p>​	新后与旧后对比，如果相同，那么新、老的结束下标往前移动一格，上图中g的新老节点相同，位置移动f位置，此时新节点为b,两节点不同，这时发现新后与旧后，新前与旧前都不满足，进入新后与旧后比对</p>
<h3 id="新后与旧前"><a href="#新后与旧前" class="headerlink" title="新后与旧前"></a>新后与旧前</h3><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c5d49cd732e4c099ed373864b7c3170~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="image.png" style="zoom:80%;" />

<p>​	新后与旧前对比，如果相同，那么把老的开始节点移动到老的结束节点后面，然后老的开始下标往后移动一格，新的结束下标往前移动一格。这时发现新的位置以上3种都不能满足，进入新前与旧后比对</p>
<h3 id="新前与旧后"><a href="#新前与旧后" class="headerlink" title="新前与旧后"></a>新前与旧后</h3><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3503d761ce6c4c4eae752b456f227435~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="image.png" style="zoom:80%;" />

<p>新前与旧后对比，如果相同，那么把老的结束节点移动到老的开始节点前面，然后新的开始下标往后移一格，老的结束下标往前移动一格。</p>
<h3 id="暴力比对（乱序）"><a href="#暴力比对（乱序）" class="headerlink" title="暴力比对（乱序）"></a>暴力比对（乱序）</h3><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94bb37df1fb5449a9dd028a2823daa47~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="image.png" style="zoom:80%;" />

<p>​	如果节点比对的时候上面4种方法都不适用时，此时我们只能用最暴力的方法，首先我们需要循环oldChildren生成一个<code>key</code>和<code>index</code>的映射表<code>&#123;&#39;a&#39;: 0, &#39;b&#39;: 1&#125;</code>,然后我们用新的开始节点的<code>key</code>,去映射表中查找，如果找到就把该节点移动到最前面，且原来的位置用<code>undefined</code>占位，避免数组塌陷  防止老节点移动走了之后破坏了初始的映射表位置，如果没有找到就直接把新节点插入</p>
<h3 id="新节点有剩余"><a href="#新节点有剩余" class="headerlink" title="新节点有剩余"></a>新节点有剩余</h3><p>​	<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ceb4f697678d40dc9f640bc284142f4e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="image.png" style="zoom:80%;" /></p>
<p>​	有时候我们会添加新的数据，这时后上面循环结束后，newChildren还有剩余的节点还没有处理，我们需要循环这些节点，逐个插入。如上图所示。当<strong>oldStartIndex</strong> &gt; <strong>oldEndIndex</strong>时,新的子节点还有c, d两个节点多余，需循环插入这2个节点。</p>
<h3 id="老节点有剩余"><a href="#老节点有剩余" class="headerlink" title="老节点有剩余"></a>老节点有剩余</h3><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37c9beae6f4f4dad9a89a0d54ea4c930~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="image.png" style="zoom:80%;" />



<p>​	另一种情况就是当我们删除元素，这时当对比循环结束后，oldChildren还有剩余的节点还没有处理，我们需循环这些节点，逐个删除。如上图所示。当<strong>newStartIndex</strong> &gt; <strong>newEndIndex</strong>时，老的子节点还有c,d两个节点多余，循环删除这2个节点</p>
<h3 id="全部核心代码"><a href="#全部核心代码" class="headerlink" title="全部核心代码"></a>全部核心代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// diff算法核心 采用双指针的方式 对比新老vnode的儿子节点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateChildren</span>(<span class="params">el, oldChildren, newChildren</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> oldStartIndex = <span class="number">0</span>; <span class="comment">// 老儿子的开始下标</span></span><br><span class="line">  <span class="keyword">let</span> oldStartVnode = oldChildren[<span class="number">0</span>]; <span class="comment">// 老儿子的第一个节点</span></span><br><span class="line">  <span class="keyword">let</span> oldEndIndex = oldChildren.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 老儿子的结束下标</span></span><br><span class="line">  <span class="keyword">let</span> oldEndVnode = oldChildren[oldEndIndex] <span class="comment">// 老儿子的最后一个节点</span></span><br><span class="line">  <span class="keyword">let</span> newStartIndex = <span class="number">0</span>; <span class="comment">// 新儿子的开始下标</span></span><br><span class="line">  <span class="keyword">let</span> newStartVnode = newChildren[<span class="number">0</span>]; <span class="comment">// 新儿子的第一个节点</span></span><br><span class="line">  <span class="keyword">let</span> newEndIndex = newChildren.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 新儿子的结束下标</span></span><br><span class="line">  <span class="keyword">let</span> newEndVnode = newChildren[newEndIndex] <span class="comment">// 新儿子的最后一个节点</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 根据key来创建老的儿子的index映射表，如&#123;&#x27;a&#x27;: 0, &#x27;b&#x27;: 1&#125;代表key为&#x27;a&#x27;的节点在第一个位置，&#x27;b&#x27;在第二个位置</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">makeIndexBykey</span> = (<span class="params">children</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> children.<span class="title function_">reduce</span>(<span class="function">(<span class="params">memo, cur, index</span>) =&gt;</span> &#123;</span><br><span class="line">      memo[cur.<span class="property">key</span>] =  index</span><br><span class="line">      <span class="keyword">return</span> memo</span><br><span class="line">    &#125;, &#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> keysMap = <span class="title function_">makeIndexBykey</span>(oldChildren)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 只有当新、老儿子的开始下标都小于等于结束下标时才循环，一方不满足就结束循环</span></span><br><span class="line">  <span class="keyword">while</span>(oldStartIndex &lt;= oldEndIndex &amp;&amp; newStartIndex &lt;= newEndIndex) &#123;</span><br><span class="line">     <span class="comment">// 因为暴力对比过程把移动的vnode置为 undefined 如果不存在节点直接跳过</span></span><br><span class="line">    <span class="keyword">if</span> (!oldStartVnode) &#123; </span><br><span class="line">        <span class="comment">// 开始位置 向后 +1</span></span><br><span class="line">      oldStartVnode = oldChildren[++oldStartIndex]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!oldEndVnode) &#123;</span><br><span class="line">        <span class="comment">// 结束位置 向前 -1</span></span><br><span class="line">      oldEndVnode = oldChildren[--oldEndIndex]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isSameVnode</span>(oldStartVnode, newStartVnode)) &#123; </span><br><span class="line">      <span class="comment">// 新前和后前相同</span></span><br><span class="line">      <span class="comment">// 递归比较儿子以及他们的子节点</span></span><br><span class="line">      <span class="title function_">patch</span>(oldStartVnode, newStartVnode)</span><br><span class="line">      <span class="comment">// 新，老开始下标 +1， 对应的节点变为 +1 后的节点</span></span><br><span class="line">      oldStartVnode = oldChildren[++oldStartIndex]</span><br><span class="line">      newStartVnode = newChildren[++newStartIndex]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isSameVnode</span>(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">      <span class="comment">// 新后和旧后相同</span></span><br><span class="line">      <span class="comment">// 递归比较儿子以及他们的子节点</span></span><br><span class="line">      <span class="title function_">patch</span>(oldEndVnode, newEndVnode)</span><br><span class="line">      <span class="comment">// 新，老结束下标 -1， 对应的节点变为 -1 后的节点</span></span><br><span class="line">      oldEndVnode = oldChildren[--oldEndIndex]</span><br><span class="line">      newEndVnode = newChildren[--newEndIndex]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isSameVnode</span>(oldStartVnode, newEndVnode)) &#123; </span><br><span class="line">      <span class="comment">// 新后和旧前相同</span></span><br><span class="line">      <span class="comment">// 递归比较儿子以及他们的子节点</span></span><br><span class="line">      <span class="title function_">patch</span>(oldStartVnode, newEndVnode)</span><br><span class="line">      <span class="comment">// 开始节点的真实dom,移动到结束节点的下一个前点的前面</span></span><br><span class="line">      el.<span class="title function_">insertBefore</span>(oldStartVnode.<span class="property">el</span>, oldEndVnode.<span class="property">el</span>.<span class="property">nextSibling</span>)</span><br><span class="line">      <span class="comment">// 老的开始下标 +1， 对应的节点变为 +1 后的节点</span></span><br><span class="line">      oldStartVnode = oldChildren[++oldStartIndex]</span><br><span class="line">      <span class="comment">// 新的结束下标 -1， 对应的节点变为 -1 后的节点</span></span><br><span class="line">      newEndVnode = newChildren[--newEndIndex]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isSameVnode</span>(oldEndVnode, newStartVnode)) &#123; </span><br><span class="line">      <span class="comment">// 新前和旧后相同</span></span><br><span class="line">      <span class="comment">// 递归比较儿子以及他们的子节点</span></span><br><span class="line">      <span class="title function_">patch</span>(oldEndVnode, newStartVnode)</span><br><span class="line">      <span class="comment">// 结束结束的真实dom，移动到开始节点的前面</span></span><br><span class="line">      el.<span class="title function_">insertBefore</span>(oldEndVnode.<span class="property">el</span>, oldStartVnode.<span class="property">el</span>)</span><br><span class="line">      <span class="comment">// 老的结束下标 -1， 对应的节点变为 -1 后的节点</span></span><br><span class="line">      oldEndVnode = oldChildren[--oldEndIndex]</span><br><span class="line">      <span class="comment">// 新的开始下标 +1， 对应的节点变为 +1 后的节点</span></span><br><span class="line">      newStartVnode = newChildren[++newStartIndex]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 上述四种情况都不满足 那么需要暴力比对</span></span><br><span class="line">      <span class="comment">// 用新的开始节点的key，去老的子节点生成的映射表中查找</span></span><br><span class="line">      <span class="keyword">const</span> moveIndex = keysMap[newStartVnode.<span class="property">key</span>]</span><br><span class="line">      <span class="keyword">if</span> (!moveIndex) &#123; </span><br><span class="line">        <span class="comment">// 如果没有找到直接把新节点的真实dom，插入到旧的开始节点的真实dom前面</span></span><br><span class="line">        el.<span class="title function_">insertBefore</span>(<span class="title function_">createElm</span>(newStartVnode), oldStartVnode.<span class="property">el</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 如果找到，取出该节点</span></span><br><span class="line">        <span class="keyword">const</span> moveNode = oldChildren[moveIndex] </span><br><span class="line">        <span class="comment">// 原来的位置用undefined占位 避免数组塌陷  防止老节点移动走了之后破坏了初始的映射表位置</span></span><br><span class="line">        oldChildren[moveIndex] = <span class="literal">undefined</span></span><br><span class="line">        <span class="comment">// 把取出的节点的真实dom插入到开始节点的真实dom前面</span></span><br><span class="line">        el.<span class="title function_">insertBefore</span>(moveNode.<span class="property">el</span>, oldStartVnode.<span class="property">el</span>)</span><br><span class="line">        <span class="title function_">patch</span>(newStartVnode, moveNode) <span class="comment">//比较</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 新的开始下标 +1, 对应的节点变为 +1 后的节点</span></span><br><span class="line">      newStartVnode = newChildren[++newStartIndex]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果老节点循环完毕了 但是新节点还有，如用户追加了一个，需要把剩余的节点插入</span></span><br><span class="line">  <span class="keyword">if</span> (newStartIndex &lt;= newEndIndex ) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = newStartIndex; i &lt;= newEndIndex; i++) &#123;</span><br><span class="line">      <span class="comment">// 这是一个优化写法 insertBefore的第一个参数是null等同于appendChild作用</span></span><br><span class="line">      <span class="comment">// 看一下 结束指针的下一个元素是否存在</span></span><br><span class="line">      <span class="keyword">let</span> anchor = newChildren[newEndIndex + <span class="number">1</span>] == <span class="literal">null</span> ? <span class="literal">null</span> : newChildren[newEndIndex + <span class="number">1</span>].<span class="property">el</span></span><br><span class="line">      el.<span class="title function_">insertBefore</span>(<span class="title function_">createElm</span>(newChildren[i]), anchor)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果新节点循环完毕了 但是老节点还有，如用户删除一个，需要把剩余的节点删除</span></span><br><span class="line">  <span class="keyword">if</span> (oldStartIndex &lt;= oldEndIndex) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = oldStartIndex; i &lt;= oldEndIndex; i++) &#123;</span><br><span class="line">       <span class="comment">// 该节点不是占位节点，才做删除操作</span></span><br><span class="line">      <span class="keyword">if</span> (oldChildren[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">        el.<span class="title function_">removeChild</span>(oldChildren[i].<span class="property">el</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"># &#125;</span><br></pre></td></tr></table></figure>

<h3 id="vue2-双端diff算法流程图"><a href="#vue2-双端diff算法流程图" class="headerlink" title="vue2 双端diff算法流程图"></a>vue2 双端diff算法流程图</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a174499e4ef64a9a80a2c2e94d5a71fb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="WechatIMG246.png"></p>
<h2 id="Vue3-快速diff算法的实现"><a href="#Vue3-快速diff算法的实现" class="headerlink" title="Vue3 快速diff算法的实现"></a>Vue3 快速diff算法的实现</h2><p>​		vue3 使用了<code>快速diff算法</code>，核心方法是<code>patchKeyedChildren</code>,首先是借鉴了纯文本diff算法中的预处理思路,处理新旧两个组子节点中相同的前置节点和后置节点。处理完后，如果剩余节点无法简单的通过挂载新节点或者卸载已经不存在的节点来完成更新，则需要根据节点的索引关系，构建出一个最长递增子序列。最长递增子序列所指向的节点即为不需要移动的节点。</p>
<h3 id="相同前置节点处理"><a href="#相同前置节点处理" class="headerlink" title="相同前置节点处理"></a>相同前置节点处理</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f24a7e5c27c41c7b265c1fb12bbc30b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p>
<p>​		前置节点的处理是定义了一个<code>j</code>变量,分别指向新，老两个组子节点，比较指向的新，老节点是否相同，如果相同指针 <code>+1</code>,直到两个节点不同时结束前置节点的处理</p>
<h3 id="相同后置节点处理"><a href="#相同后置节点处理" class="headerlink" title="相同后置节点处理"></a>相同后置节点处理</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/174b0dd18288437f82fabec0471291cd~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p>
<p>​		后置节点的处理是定义了索引oldEnd指向旧的一组子节点的最后一个节点和索引newEnd指向新的一组子节点的最后一个节点。然后比较两个指向的新旧节点，如果相同指向 <code>-1</code>，直到两个节点不同时结束后置节点的处理</p>
<h3 id="剩余节点的处理"><a href="#剩余节点的处理" class="headerlink" title="剩余节点的处理"></a>剩余节点的处理</h3><p>​		当我们处理完相同的前置节点和后置节点后，如果还有剩余节点，就要对剩余节点进行处理，剩余节点分为3中情况，分别是<code>只有新的一组的子节点有剩余</code>,<code>只有老的一组的子节点有剩余</code>,<code>新老两组的子节点都有剩余</code>；</p>
<h3 id="只有新的一组的子节点有剩余"><a href="#只有新的一组的子节点有剩余" class="headerlink" title="只有新的一组的子节点有剩余"></a>只有新的一组的子节点有剩余</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67ecfc7484594fca8deaa023db2a8254~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p>
<p>​		当条件满足<code>j &gt; oldEnd</code> 且 <code>j &lt;= newEnd</code>时，表示只有新的一组的子节点还有未处理的节点，我们需要循环 <code>j -&gt; newEnd</code>中的节点进行插入</p>
<h3 id="只有老的一组的子节点有剩余"><a href="#只有老的一组的子节点有剩余" class="headerlink" title="只有老的一组的子节点有剩余"></a>只有老的一组的子节点有剩余</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33149e564b564c1d920cbe061f02cc62~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"> 		当条件满足 <code>j &gt; newEnd</code> 且 <code>j &lt;= oldEnd</code>时，表示只有老的一组的子节点还有未处理的节点，我们需要循环 <code>j -&gt; oldEnd</code>中的节点进行删除</p>
<h3 id="新老两组的子节点都有剩余"><a href="#新老两组的子节点都有剩余" class="headerlink" title="新老两组的子节点都有剩余"></a>新老两组的子节点都有剩余</h3><p>​		该状态下主要核心为3个部分：<br> <strong>构建source数组用于存放新的一组子节点每个节点在老的一组中存在的原来位置(索引)</strong> 首先是定义一个长度为剩余新的一组子节点的长度的数组<code>source</code>，初始值都为<code>-1</code>，还定义了一个变量<code>patched</code>用于记录，然后遍历新的一组子节点，构建<code>key</code>与<code>index</code>的映射表，最后遍历老的一组节点，去映射表中寻找，<code>k = keyIndex[oldVnode.key];</code>，如果找到就把对应的索引存入到<code>source</code>对应的位置中，没有找到说明该节点多余，直接删除。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bc76f733f174876aabc47e930c8742a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"> 		<strong>判断是否需要移动节点</strong>，首页我们定义两个变量，<code>moved</code>用于记录是否需要移动的阀值,<code>pos</code>用与记录最后一个节点在新的里面的索引，最后用上述去映射寻找到值<code>k</code> 与 <code>pos</code>寻找，如果 <code>k &lt; pos</code>,说明不是升序需要移动, 否则 <code>pos = k</code></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e97268a09c94cbaad2998e797bbc0ec~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"> 		<strong>利用最长递增子序列来优化移动逻辑</strong>，如果<code>moved = true</code>, 首先通过最长递增子序列获取到升序列表<code>存放的是索引</code>，然后从后遍历新的一组节点,节点的索引与升序列表对比，如果对比上了说明不需要移动，否则需要移动。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43939ea17f9f4680a2471aa6826103a8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="image.png"></p>
<h3 id="全部核心代码-1"><a href="#全部核心代码-1" class="headerlink" title="全部核心代码"></a>全部核心代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">  // 获取新的子节点</span><br><span class="line">  const newChildren = n2.children;</span><br><span class="line">  // 获取老的子节点</span><br><span class="line">  const oldChildren = n1.children;</span><br><span class="line">  // 更新相同的前置节点</span><br><span class="line">  // 新，老开始节点的下标</span><br><span class="line">  let j = 0;</span><br><span class="line">  // 获取老的一组子节点的开始节点</span><br><span class="line">  let oldVnode = oldChildren[j];</span><br><span class="line">  // 获取新的一组子节点的开始节点</span><br><span class="line">  let newVnode = newChildren[j];</span><br><span class="line">  // 如果新，老的开始节点相同</span><br><span class="line">  while(oldVnode.key === newChildren.key) &#123;</span><br><span class="line">    // 递归处理子节点</span><br><span class="line">    patch(oldVnode, newVnode, container);</span><br><span class="line">    // 下标往后移动一格</span><br><span class="line">    j++;</span><br><span class="line">    // 获取 +1 后的新，老节点</span><br><span class="line">    oldVnode = oldChildren[j];</span><br><span class="line">    newVnode = newChildren[j];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 更新相同的后置节点</span><br><span class="line">  // 索引 oldEnd 指向旧的一组子节点的最后一个节点</span><br><span class="line">  let oldEnd = oldChildren.length - 1;</span><br><span class="line">  // 索引 newEnd 指向新的一组子节点的最后一个节点</span><br><span class="line">  let newEnd = newChildren.length - 1;</span><br><span class="line">  // 获取新，老结束下标对应的节点</span><br><span class="line">  oldVnode = oldChildren[oldEnd];</span><br><span class="line">  newVnode = newChildren[newEnd];</span><br><span class="line"></span><br><span class="line">  // 如果新，老的结束节点相同</span><br><span class="line">  while(oldVnode.key === newVnode.key) &#123;</span><br><span class="line">    // 递归处理子节点</span><br><span class="line">    patch(oldVnode, newVnode, container)</span><br><span class="line">    // 递减 oldEnd 和 nextEnd</span><br><span class="line">    oldEnd--</span><br><span class="line">    newEnd--</span><br><span class="line">    // 获取递减对应的节点</span><br><span class="line">    oldVnode = oldChildren[oldEnd]</span><br><span class="line">    newVnode = newChildren[newEnd]</span><br><span class="line">  &#125;</span><br><span class="line">  // 预处理完毕后，如果满足如下条件，则说明从 j --&gt; newEnd 之间的节点应该作为新节点插入</span><br><span class="line">  if (j &gt; oldEnd &amp;&amp; j &lt;= newEnd) &#123;</span><br><span class="line">    // 锚点的索引</span><br><span class="line">    const anchorIndex = newEnd + 1;</span><br><span class="line">    // 锚点元素</span><br><span class="line">    const anchor = anchorIndex &lt; newChildren.length ? newChildren[anchorIndex].el : null;</span><br><span class="line">    // 采用 while 循环， 调用 patch 函数逐个挂载新增节点</span><br><span class="line">    while (j &lt;= newEnd) &#123;</span><br><span class="line">      patch(null, newChildren[j++], container, anchor)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (j &gt; newEnd &amp;&amp; j &lt;= oldEnd) &#123;</span><br><span class="line">    // 如果满足如下条件以上条件，那么j --&gt; oldEnd 之间的节点应该被卸载</span><br><span class="line">    while (j &lt;= oldEnd) &#123;</span><br><span class="line">        // 循环卸载多余节点</span><br><span class="line">      unmount(oldChildren[j++])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 获取剩余新的一组子节点的个数</span><br><span class="line">    const count = newEnd - j + 1;</span><br><span class="line">    // 定义个长度为 count 的 数组，用于存放新的一组子节点在老的组中位置，果然没有的话就存-1</span><br><span class="line">    const source = new Array(count);</span><br><span class="line">    // 初始化都存放-1</span><br><span class="line">    source.fill(-1);</span><br><span class="line"></span><br><span class="line">    // oldStart 和 newStart 分别为起始索引，即j</span><br><span class="line">    const oldStart = j;</span><br><span class="line">    const newStart = j;</span><br><span class="line">    // 用于最后判断是否有要移动的节点</span><br><span class="line">    let moved = false;</span><br><span class="line">    // 用于存放寻找过程中找递增序列中最大索引值</span><br><span class="line">    let pos = 0;</span><br><span class="line">    // 循环新的一组的子节点，构建key 和 index 的映射表</span><br><span class="line">    const keyIndex = &#123;&#125;;</span><br><span class="line">    for(let i = newStart; i &lt;= newEnd; i++) &#123;</span><br><span class="line">      keyIndex[newChildren[i].key] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    // 代表更新过的节点数量</span><br><span class="line">    let patched = 0;</span><br><span class="line">    // 遍历旧的一组子节点中剩余未处理的节点</span><br><span class="line">    for(let i = oldStart; i &lt;= oldEnd; i++) &#123;</span><br><span class="line">      oldVnode = oldChildren[i];</span><br><span class="line">      // 如果更新过的节点数量小于等于需要更新的节点数量，则执行更新</span><br><span class="line">      if (patched &lt;= count) &#123;</span><br><span class="line">         // 取出老节点在新节点的索引</span><br><span class="line">        const k = keyIndex[oldVnode.key];</span><br><span class="line">        if (typeof k !== &#x27;undefined&#x27;) &#123;</span><br><span class="line">          newVnode = newChildren[k];</span><br><span class="line">           // 递归处理子节点</span><br><span class="line">          patch(oldVnode, newVnode, container);</span><br><span class="line">          // 每更新一个节点，都将 patched 变量 +1</span><br><span class="line">          patched++;</span><br><span class="line">          // 存放新的一组子节点在老的组中位置 </span><br><span class="line">          source[k - newStart] = i;</span><br><span class="line">          // 如果该节点新的位置小于最大的索引值,说明该节点往前移了</span><br><span class="line">          if (k &lt; pos) &#123;</span><br><span class="line">            moved = true</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            // 如果不是就把该位子存到pos，目前k是递增子节点中最大的索引</span><br><span class="line">            pos = k</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          // 没找到, 卸载该节点</span><br><span class="line">          unmount(oldVnode)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 如果更新过的节点数量大于需要更新的节点数量，则卸载多余的节点</span><br><span class="line">        unmount(oldVnode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   // moved 为 true 时说明需要移动节点 </span><br><span class="line">  if (moved) &#123;</span><br><span class="line">    // 计算最长递增子序列</span><br><span class="line">    const seq = lis(source);</span><br><span class="line">    // 最长递增子序列中最后一个值的索引</span><br><span class="line">    let s = seq.length - 1;</span><br><span class="line">    // 新的一组子节点的最后一个节点的索引</span><br><span class="line">    let i = count - 1;</span><br><span class="line">    // 新的一组子节点从后往前遍历</span><br><span class="line">    for (i; i &gt;=0; i--) &#123;</span><br><span class="line">      if (source[i] === -1) &#123;</span><br><span class="line">        // 说明索引为 i 的节点是全新的节点，应该将其插入</span><br><span class="line">        // 该节点在新 children 中的真实位置索引</span><br><span class="line">        const pos = i + newStart;</span><br><span class="line">        const newVnode = newChildren[pos];</span><br><span class="line">        // 该节点的下一个节点的位置索引；</span><br><span class="line">        const nextPos = pos + 1;</span><br><span class="line">        // 锚点</span><br><span class="line">        const anchor = nextPos &lt; newChildren.length ? newChildren[nextPos].el : null;</span><br><span class="line">        // 挂载</span><br><span class="line">        patch(null, newVnode, container, anchor);</span><br><span class="line">      &#125; else if(i !== seq[s]) &#123;</span><br><span class="line">        // 如果节点的索引 i 不等于 seq[s] 的值， 说明该节点需要移动</span><br><span class="line">        // 该节点在新的一组子节中的真实位置索引</span><br><span class="line">        const pos = i + newStart;</span><br><span class="line">        const newVnode = newChildren[pos];</span><br><span class="line">        // 该节点的下一个节点的位置索引</span><br><span class="line">        const nextPos = pos + 1;</span><br><span class="line">        // 锚点</span><br><span class="line">        const anchor = nextPos &lt; newChildren.length ? newChildren[nextPos].el : null;</span><br><span class="line">        // 移动</span><br><span class="line">        insert(newVnode.el, container, anchor)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 当 i === seq[s] 时, 说明该位置的节点不需要移动，只需要让 s 指向下一个位置</span><br><span class="line">        s--</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="Vue3-快速diff算法流程图-放大查看"><a href="#Vue3-快速diff算法流程图-放大查看" class="headerlink" title="Vue3 快速diff算法流程图(放大查看)"></a>Vue3 快速diff算法流程图(放大查看)</h2><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7b7f994d74040cd8e288a93404ccecb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="WechatIMG248.png"></p>
<h2 id="Vue2-和-Vue3-diff-算法的区别"><a href="#Vue2-和-Vue3-diff-算法的区别" class="headerlink" title="Vue2 和 Vue3 diff 算法的区别"></a>Vue2 和 Vue3 diff 算法的区别</h2><p><strong>vue2是全量进行diff,而vue3使用了静态标记,只对打标记的节点进行diff</strong></p>
<p>vue2中的虚拟dom是进行<strong>全量的对比</strong>，在运行时会对所有节点生成一个虚拟节点树，当页面数据发生变更好，会遍历判断虚拟dom所有节点（包括一些不会变化的节点）有没有发生变化；vue3在diff算法中相比vue2增加了静态标记, 在模版编译时，编译器会在动态标签末尾加上 &#x2F;* Text*&#x2F; PatchFlag。<strong>也就是在生成VNode的时候，同时打上标记</strong>，patch 过程中就会判断这个标记来 Diff 优化流程，跳过一些静态节点对比</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 源码中所有 PatchFlags 值</span><br><span class="line">export const enum PatchFlags &#123;</span><br><span class="line">  TEXT = 1 ,  // 动态文本节点</span><br><span class="line">  CLASS = 1 &lt;&lt; 1,  // 2   动态class</span><br><span class="line">  STYLE = 1 &lt;&lt; 2,  // 4   动态style</span><br><span class="line">  PROPS = 1 &lt;&lt; 3,  // 8   除去class/style以外的动态属性</span><br><span class="line">  FULL_PROPS = 1 &lt;&lt; 4,       // 16  有动态key属性的节点，当key改变时，需进行完整的diff比较</span><br><span class="line">  HYDRATE_EVENTS = 1 &lt;&lt; 5,   // 32  有监听事件的节点</span><br><span class="line">  STABLE_FRAGMENT = 1 &lt;&lt; 6,  // 64  一个不会改变子节点顺序的fragment (一个组件内多个根元素就会用fragment包裹)</span><br><span class="line">  KEYED_FRAGMENT = 1 &lt;&lt; 7,   // 128 带有key属性的fragment或部分子节点有key</span><br><span class="line">  UNKEYEN_FRAGMENT = 1 &lt;&lt; 8, // 256  子节点没有key的fragment</span><br><span class="line">  NEED_PATCH = 1 &lt;&lt; 9,       // 512  一个节点只会进行非props比较</span><br><span class="line">  DYNAMIC_SLOTS = 1 &lt;&lt; 10,   // 1024   动态slot</span><br><span class="line">  HOISTED = -1,  // 静态节点 </span><br><span class="line">  BAIL = -2      // 表示 Diff 过程中不需要优化</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">想名是真的难</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/post/4a17b156.html">http://example.com/post/4a17b156.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Promise</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Vue3/">Vue3</a></div><div class="post_share"><div class="social-share" data-image="https://picx.zhimg.com/80/v2-781cbee858456bdb05399d0569b11416_720w.webp?source=1940ef5c" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">想名是真的难</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">1</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/oblvpromise" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1404498355@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BAVue3%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.</span> <span class="toc-text">构建Vue3项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue2%E4%B8%8EVue3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">Vue2与Vue3的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FDOM"><span class="toc-number">3.</span> <span class="toc-text">虚拟DOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E4%B8%AD%E7%9A%84Diff%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">Vue中的Diff算法：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue2Diff%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">Vue2Diff算法：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%89%8D%E4%B8%8E%E6%97%A7%E5%89%8D"><span class="toc-number">5.1.</span> <span class="toc-text">新前与旧前</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%90%8E%E4%B8%8E%E6%97%A7%E5%90%8E"><span class="toc-number">5.2.</span> <span class="toc-text">新后与旧后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%90%8E%E4%B8%8E%E6%97%A7%E5%89%8D"><span class="toc-number">5.3.</span> <span class="toc-text">新后与旧前</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%89%8D%E4%B8%8E%E6%97%A7%E5%90%8E"><span class="toc-number">5.4.</span> <span class="toc-text">新前与旧后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E6%AF%94%E5%AF%B9%EF%BC%88%E4%B9%B1%E5%BA%8F%EF%BC%89"><span class="toc-number">5.5.</span> <span class="toc-text">暴力比对（乱序）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E8%8A%82%E7%82%B9%E6%9C%89%E5%89%A9%E4%BD%99"><span class="toc-number">5.6.</span> <span class="toc-text">新节点有剩余</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%81%E8%8A%82%E7%82%B9%E6%9C%89%E5%89%A9%E4%BD%99"><span class="toc-number">5.7.</span> <span class="toc-text">老节点有剩余</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E9%83%A8%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81"><span class="toc-number">5.8.</span> <span class="toc-text">全部核心代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue2-%E5%8F%8C%E7%AB%AFdiff%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">5.9.</span> <span class="toc-text">vue2 双端diff算法流程图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue3-%E5%BF%AB%E9%80%9Fdiff%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.</span> <span class="toc-text">Vue3 快速diff算法的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E5%89%8D%E7%BD%AE%E8%8A%82%E7%82%B9%E5%A4%84%E7%90%86"><span class="toc-number">6.1.</span> <span class="toc-text">相同前置节点处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E5%90%8E%E7%BD%AE%E8%8A%82%E7%82%B9%E5%A4%84%E7%90%86"><span class="toc-number">6.2.</span> <span class="toc-text">相同后置节点处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%A9%E4%BD%99%E8%8A%82%E7%82%B9%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">6.3.</span> <span class="toc-text">剩余节点的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E6%9C%89%E6%96%B0%E7%9A%84%E4%B8%80%E7%BB%84%E7%9A%84%E5%AD%90%E8%8A%82%E7%82%B9%E6%9C%89%E5%89%A9%E4%BD%99"><span class="toc-number">6.4.</span> <span class="toc-text">只有新的一组的子节点有剩余</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E6%9C%89%E8%80%81%E7%9A%84%E4%B8%80%E7%BB%84%E7%9A%84%E5%AD%90%E8%8A%82%E7%82%B9%E6%9C%89%E5%89%A9%E4%BD%99"><span class="toc-number">6.5.</span> <span class="toc-text">只有老的一组的子节点有剩余</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E8%80%81%E4%B8%A4%E7%BB%84%E7%9A%84%E5%AD%90%E8%8A%82%E7%82%B9%E9%83%BD%E6%9C%89%E5%89%A9%E4%BD%99"><span class="toc-number">6.6.</span> <span class="toc-text">新老两组的子节点都有剩余</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E9%83%A8%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81-1"><span class="toc-number">6.7.</span> <span class="toc-text">全部核心代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue3-%E5%BF%AB%E9%80%9Fdiff%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE-%E6%94%BE%E5%A4%A7%E6%9F%A5%E7%9C%8B"><span class="toc-number">7.</span> <span class="toc-text">Vue3 快速diff算法流程图(放大查看)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue2-%E5%92%8C-Vue3-diff-%E7%AE%97%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.</span> <span class="toc-text">Vue2 和 Vue3 diff 算法的区别</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/4a17b156.html" title="Vue3开篇">Vue3开篇</a><time datetime="2023-03-21T08:21:05.662Z" title="发表于 2023-03-21 16:21:05">2023-03-21</time></div></div></div></div></div></div></main><footer id="footer" style="background: #B0BEC5"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 想名是真的难</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>